#!/usr/bin/env ruby
# begin # XXX: Remove this begin/rescue before distributing your app
 require 'banalize'
# rescue LoadError
#   STDERR.puts "In development, you need to use `bundle exec bin/Banalize` to run your app"
#   STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
#   STDERR.puts "Feel free to remove this message from bin/Banalize now"
#   exit 64
# end

#require_relative File.dirname(File.dirname(__FILE__))

include GLI::App
commands_from "commands"

program_desc <<-EOF 

Banalize is Bash files static code analyzer. It runs each policy
corresponding to the required level of test severity and policies. 

Policies are Ruby or other programming languages (Bash, perl)
executable scripts located in `lib/policies` directories.

EOF


version Banalize::VERSION



desc 'Use only policies included in specified group'
# default_value 'core'
flag [:group, :g]


desc 'Policies of specified severity and above'
flag [:severity, :s]

desc 'Single policy only by name'
flag [:policy, :p]


pre do |global,command,options,args|
  
  search = { } 

  if global[:policy]
    search = global[:policy]

  else
    search.merge!({ :policy   => global[:group]         }) if global[:group]
    search.merge!({ :severity => global[:severity].to_i }) if global[:severity]
  end

  $search   = search
  $policies = Banalize::Policy.search search 

  $res, $status = { }, true
  # Return true to proceed; false to abort and not call the
  true
end

post do |global,command,options,args|

  # output results of the check
  unless $res.empty?

    if options[:d]
      out = ''
      $res.each do |file,res|
        res.each do |k,v|
          out << (v ? '.' : "F")
          $status &&= v
        end
      end
      puts out

    else
      out = { }
      $res.each do |file,res|
        failure = res.select { |k,v| !v }
        status &&= ! failure.empty?
        
        out[file] = { "Fail" => failure }
        out[file].merge!({ "Success" => res.select { |k,v| v } }) if options[:all]
      end

      print out.to_yaml
    end
  end

  $status
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV) && $status
